/* Process IKEv2 IKE_SA_INIT packets, for libreswan
 *
 * Copyright (C) 1997 Angelos D. Keromytis.
 * Copyright (C) 1998-2010,2013-2017 D. Hugh Redelmeier <hugh@mimosa.com>
 * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>
 * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
 * Copyright (C) 2008-2011 Paul Wouters <paul@xelerance.com>
 * Copyright (C) 2010 Simon Deziel <simon@xelerance.com>
 * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
 * Copyright (C) 2011-2012 Avesh Agarwal <avagarwa@redhat.com>
 * Copyright (C) 2012 Paul Wouters <paul@libreswan.org>
 * Copyright (C) 2012-2019 Paul Wouters <pwouters@redhat.com>
 * Copyright (C) 2013 Matt Rogers <mrogers@redhat.com>
 * Copyright (C) 2015-2019 Andrew Cagney
 * Copyright (C) 2016-2018 Antony Antony <appu@phenome.org>
 * Copyright (C) 2017 Sahana Prasad <sahana.prasad07@gmail.com>
 * Copyright (C) 2020 Yulia Kuzovkova <ukuzovkova@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */

#include "defs.h"
#include "demux.h"
#include "log.h"
#include "ikev2_ike_sa_init.h"
#include "state.h"
#include "ikev2_send.h"
#include "ikev2_redirect.h"
#include "ikev2_host_pair.h"
#include "ikev2_states.h"
#include "vendor.h"
#include "ikev2_cookie.h"
#include "ikev2.h"

void process_v2_IKE_SA_INIT(struct msg_digest *md)
{
	/*
	 * The message ID of the initial exchange is always
	 * zero.
	 */
	if (md->hdr.isa_msgid != 0) {
		rate_log(md, "IKE_SA_INIT message has non-zero message ID; dropping packet");
		return;
	}
	/*
	 * Now try to find the state
	 */
	switch (v2_msg_role(md)) {

	case MESSAGE_REQUEST:
	{

		/*
		 * 3.1.  The IKE Header (Flags)
		 *
		 * * I (Initiator) - This bit MUST be set in messages
		 *   sent by the original initiator of the IKE SA and
		 *   MUST be cleared in messages sent by the original
		 *   responder.  It is used by the recipient to
		 *   determine which eight octets of the SPI were
		 *   generated by the recipient.  This bit changes to
		 *   reflect who initiated the last rekey of the IKE
		 *   SA.
		 *
		 * i.e., in the request, I must be set
		 */
		if (!(md->hdr.isa_flags & ISAKMP_FLAGS_v2_IKE_I)) {
			rate_log(md, "IKE_SA_INIT request has I (IKE Initiator) flag clear; dropping packet");
			return;
		}

		/*
		 * 3.1.  The IKE Header (IKE SA Initiator SPI)
		 *
		 * o Initiator's SPI (8 octets) - A value chosen by
		 *   the initiator to identify a unique IKE Security
		 *   Association.  This value MUST NOT be zero.
		 *
		 * (it isn't obvious why this rule is needed;
		 * exchanges still work)
		 */
		if (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {
			rate_log(md, "IKE_SA_INIT request has zero IKE SA Initiator SPI; dropping packet");
			return;
		}

		/*
		 * 3.1.  The IKE Header (IKE SA Responder SPI)
		 *
		 * o Responder's SPI (8 octets) - A value chosen by
		 *   the responder to identify a unique IKE Security
		 *   Association.  This value MUST be zero in the
		 *   first message of an IKE initial exchange
		 *   (including repeats of that message including a
		 *   cookie).
		 *
		 * (since this is the very first message, the
		 * initiator can't know the responder's SPI).
		 */
		if (!ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {
			rate_log(md, "IKE_SA_INIT request has non-zero IKE SA Responder SPI; dropping packet");
			return;
		}

		/*
		 * Look for a pre-existing IKE SA responder state
		 * using just the SPIi (SPIr in the message is zero so
		 * can't be used).
		 *
		 * XXX: RFC 7296 says this isn't sufficient:
		 *
		 *   2.1.  Use of Retransmission Timers
		 *
		 *   Retransmissions of the IKE_SA_INIT request
		 *   require some special handling.  When a responder
		 *   receives an IKE_SA_INIT request, it has to
		 *   determine whether the packet is a retransmission
		 *   belonging to an existing "half-open" IKE SA (in
		 *   which case the responder retransmits the same
		 *   response), or a new request (in which case the
		 *   responder creates a new IKE SA and sends a fresh
		 *   response), or it belongs to an existing IKE SA
		 *   where the IKE_AUTH request has been already
		 *   received (in which case the responder ignores
		 *   it).
		 *
		 *   It is not sufficient to use the initiator's SPI
		 *   and/or IP address to differentiate between these
		 *   three cases because two different peers behind a
		 *   single NAT could choose the same initiator SPI.
		 *   Instead, a robust responder will do the IKE SA
		 *   lookup using the whole packet, its hash, or the
		 *   Ni payload.
		 *
		 * But realistically, either there's an IOT device
		 * sending out a hardwired SPIi, or there is a clash
		 * and a retry will generate a new conflicting SPIi.
		 *
		 * If the lookup succeeds then there are several
		 * possibilities:
		 *
		 * State has Message ID == 0:
		 *
		 * Either it really is a duplicate; or it's a second
		 * (fake?) intiator sending the same SPIi at exactly
		 * the same time as the first (wow, what are the odds,
		 * it must be our lucky day!).
		 *
		 * Either way, the duplicate code needs to compare
		 * packets and decide if a retransmit or drop is
		 * required.  If the second initiator is real, then it
		 * will timeout and then retry with a new SPIi.
		 *
		 * State has Message ID > 0:
		 *
		 * Either it is an old duplicate; or, again, it's a
		 * second intiator sending the same SPIi only slightly
		 * later (again, what are the odds!).
		 *
		 * Several choices: let the duplicate code drop the
		 * packet, which is correct for an old duplicate
		 * message; or ignore the existing state and create a
		 * new one, which is good for the second initiator but
		 * not so good for an old duplicate.  Given an old
		 * duplicate is far more likely, handle that cleenly -
		 * let the duplicate code drop the packet.
		 */
		struct ike_sa *old = find_v2_ike_sa_by_initiator_spi(&md->hdr.isa_ike_initiator_spi,
								     SA_RESPONDER);
		if (old != NULL) {
			intmax_t msgid = md->hdr.isa_msgid;
			pexpect(msgid == 0); /* per above */
			/* XXX: keep test results happy */
			if (md->fake_clone) {
				log_state(RC_LOG, &old->sa, "IMPAIR: processing a fake (cloned) message");
			}
			if (verbose_state_busy(&old->sa)) {
				/* already logged */;
			} else if (old->sa.st_state->kind == STATE_PARENT_R1 &&
				   old->sa.st_v2_msgid_windows.responder.recv == 0 &&
				   old->sa.st_v2_msgid_windows.responder.sent == 0 &&
				   hunk_eq(old->sa.st_firstpacket_peer,
					   pbs_in_as_shunk(&md->message_pbs))) {
				/*
				 * It looks a lot like a shiny new IKE
				 * SA that only just responded to a
				 * message identical to this one.
				 * Re-transmit the response.
				 *
				 * XXX: Log message matches
				 * is_duplicate_request() - keep test
				 * results happy.
				 */
				log_state(RC_LOG, &old->sa,
					  "received duplicate %s message request (Message ID %jd); retransmitting response",
					  enum_name_short(&ikev2_exchange_names, md->hdr.isa_xchg),
					  msgid);
				send_recorded_v2_message(old, "IKE_SA_INIT responder retransmit",
							 MESSAGE_RESPONSE);
			} else {
				/*
				 * Either:
				 *
				 * - it is an old duplicate and the
				 *   packet should be dropped
				 *
				 * - it's a second intiator using the
				 *   same SPIi (wow!) and a new IKE SA
				 *   should be created
				 *
				 * However the odds of the later are
				 * essentially zero so assume the
				 * former and drop the packet.
				 *
				 * XXX: Log message matches
				 * is_duplicate_request() - keep test
				 * results happy.
				 */
				log_state(RC_LOG, &old->sa,
					  "received too old retransmit: %jd < %jd",
					  msgid, old->sa.st_v2_msgid_windows.responder.sent);
			}
			return;
		}

		if (drop_new_exchanges()) {
			/* only log for debug to prevent disk filling up */
			dbg("pluto is overloaded with half-open IKE SAs; dropping new exchange");
			return;
		}

		/*
		 * Always check for cookies!
		 *
		 * XXX: why?
		 *
		 * Because the v2N_COOKIE payload is first, parsing
		 * and verifying it should be relatively quick and
		 * cheap.  Right?
		 *
		 * No.  The equation uses v2Ni forcing the entire
		 * payload to be parsed.
		 *
		 * The error notification is probably INVALID_SYNTAX,
		 * but could be v2N_UNSUPPORTED_CRITICAL_PAYLOAD.
		 */
		pexpect(!md->message_payloads.parsed);
		md->message_payloads = ikev2_decode_payloads(md->md_logger, md,
							     &md->message_pbs,
							     md->hdr.isa_np);
		if (md->message_payloads.n != v2N_NOTHING_WRONG) {
			if (require_ddos_cookies()) {
				dbg("DDOS so not responding to invalid packet");
			} else {
				chunk_t data = chunk2(md->message_payloads.data,
						      md->message_payloads.data_size);
				send_v2N_response_from_md(md, md->message_payloads.n,
							  &data);
			}
			return;
		}

		/*
		 * Do I want a cookie?
		 */
		if (v2_rejected_initiator_cookie(md, require_ddos_cookies())) {
			dbg("pluto is overloaded and demanding cookies; dropping new exchange");
			return;
		}

		/*
		 * Check for v2N_REDIRECT_SUPPORTED /
		 * v2N_REDIRECTED_FROM notification.  If redirection
		 * is a MUST, try to respond with v2N_REDIRECT and
		 * don't continue further.  Otherwise continue as
		 * usual.
		 *
		 * The function below will do everything (and log the
		 * result).
		 */
		if (redirect_global(md)) {
			return;
		}

		/*
		 * Check if we would drop the packet based on VID
		 * before we create a state. Move this to
		 * ikev2_oppo.c: drop_oppo_requests()?
		 */
		for (struct payload_digest *p = md->chain[ISAKMP_NEXT_v2V]; p != NULL; p = p->next) {
			if (vid_is_oppo((char *)p->pbs.cur, pbs_left(&p->pbs))) {
				if (pluto_drop_oppo_null) {
					dbg("Dropped IKE request for Opportunistic IPsec by global policy");
					return;
				}
				dbg("Processing IKE request for Opportunistic IPsec");
				break;
			}
		}

		/*
		 * Does the message match the (only) expected
		 * transition?
		 */
		const struct finite_state *start_state = finite_states[STATE_PARENT_R0];
		const struct state_v2_microcode *transition =
			find_v2_state_transition(md->md_logger, start_state, md);
		if (transition == NULL) {
			/* already logged */
			send_v2N_response_from_md(md, v2N_INVALID_SYNTAX, NULL);
			return;
		}

		/*
		 * Is there a connection that matches the message?
		 */
		lset_t policy = LEMPTY;
		bool send_reject_response = true;
		struct connection *c = find_v2_host_pair_connection(md, &policy,
								    &send_reject_response);
		if (c == NULL) {
			if (send_reject_response) {
				/*
				 * NO_PROPOSAL_CHOSEN is used when the
				 * list of proposals is empty, like
				 * when we did not find any connection
				 * to use.
				 *
				 * INVALID_SYNTAX is for errors that a
				 * configuration change could not fix.
				 */
				send_v2N_response_from_md(md, v2N_NO_PROPOSAL_CHOSEN, NULL);
			}
			return;
		}

		/*
		 * We've committed to creating a state and,
		 * presumably, dedicating real resources to the
		 * connection.
		 */
		struct ike_sa *ike = new_v2_ike_state(c, transition, SA_RESPONDER,
						      md->hdr.isa_ike_spis.initiator,
						      ike_responder_spi(&md->sender,
									md->md_logger),
						      policy, 0, null_fd);

		statetime_t start = statetime_backdate(&ike->sa, &md->md_inception);
		/* XXX: keep test results happy */
		if (md->fake_clone) {
			log_state(RC_LOG, &ike->sa, "IMPAIR: processing a fake (cloned) message");
		}
		v2_dispatch(ike, &ike->sa, md, transition);
		statetime_stop(&start, "%s()", __func__);
		return;
	}

	case MESSAGE_RESPONSE:
	{
		/*
		 * 3.1.  The IKE Header (Flags)
		 *
		 * * I (Initiator) - This bit MUST be set in messages
		 *   sent by the original initiator of the IKE SA and
		 *   MUST be cleared in messages sent by the original
		 *   responder.  It is used by the recipient to
		 *   determine which eight octets of the SPI were
		 *   generated by the recipient.  This bit changes to
		 *   reflect who initiated the last rekey of the IKE
		 *   SA.
		 *
		 * i.e., in the response I must be clear
		 */
		if (md->hdr.isa_flags & ISAKMP_FLAGS_v2_IKE_I) {
			rate_log(md, "IKE_SA_INIT response has I (IKE Initiator) flag set; dropping packet");
			return;
		}

		/*
		 * 2.6.  IKE SA SPIs and Cookies:
		 *
		 *   When the IKE_SA_INIT exchange does not result in
		 *   the creation of an IKE SA due to
		 *   INVALID_KE_PAYLOAD, NO_PROPOSAL_CHOSEN, or
		 *   COOKIE, the responder's SPI will be zero also in
		 *   the response message.  However, if the responder
		 *   sends a non-zero responder SPI, the initiator
		 *   should not reject the response for only that
		 *   reason.
		 *
		 * i.e., can't check response for non-zero SPIr.
		 *
		 * Look for a pre-existing IKE SA responder state
		 * using just the SPIi (SPIr in the message isn't
		 * known so can't be used).
		 *
		 * An IKE_SA_INIT error notification response
		 * (INVALID_KE, COOKIE) should contain a zero SPIr (it
		 * must be ignored).
		 *
		 * An IKE_SA_INIT success response will contain an as
		 * yet unknown but non-zero SPIr so looking for it
		 * won't work.
		 */
		struct ike_sa *ike = find_v2_ike_sa_by_initiator_spi(&md->hdr.isa_ike_initiator_spi,
								     SA_INITIATOR);
		if (ike == NULL) {
			/*
			 * There should be a state matching the
			 * original initiator's IKE SPIs.  Since there
			 * isn't someone's playing games.  Drop the
			 * packet.
			 */
			rate_log(md, "dropping IKE_SA_INIT response no matching IKE ISA");
			return;
		}

		if (ike->sa.st_state->kind != STATE_PARENT_I1 ||
		    ike->sa.st_v2_msgid_windows.initiator.sent != 0 ||
		    ike->sa.st_v2_msgid_windows.initiator.recv != -1 ||
		    ike->sa.st_v2_msgid_wip.initiator != 0) {
			/*
			 * This doesn't seem right; drop the
			 * packet.
			 */
			rate_log(md, "dropping IKE_SA_INIT response as unexpected for matching IKE SA #%lu",
				 ike->sa.st_serialno);
			return;
		}

		if (verbose_state_busy(&ike->sa)) {
			return;
		}

		dbg("unpacking clear payloads");
		md->message_payloads = ikev2_decode_payloads(ike->sa.st_logger, md,
							     &md->message_pbs,
							     md->hdr.isa_np);
		if (md->message_payloads.n != v2N_NOTHING_WRONG) {
			/* already logged */
			return;
		}

		/* transition? */
		const struct state_v2_microcode *transition =
			find_v2_state_transition(ike->sa.st_logger, ike->sa.st_state, md);
		if (transition == NULL) {
			/* already logged */
			return;
		}

		statetime_t start = statetime_backdate(&ike->sa, &md->md_inception);
		v2_dispatch(ike, &ike->sa, md, transition);
		statetime_stop(&start, "%s()", __func__);
		return;
	}

	default:
		bad_case(v2_msg_role(md));
	}

}
